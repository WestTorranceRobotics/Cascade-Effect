#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,      ,             tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     Roller,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LeftMotor,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     Forebar,       tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     RightMotor,    tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     Winch,         tmotorTetrix, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

int STARTING_ENCODER;

void initializeRobot()
{
	// Place code here to initialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	// init motors


	/*

	joy 1:
		everything regular

	joy 2:
		intake = 2
		output = 3
		forebar high = 5
		forebar rest = 8

	*/
	motor[LeftMotor] = 0;
	motor[RightMotor] = 0;
	motor[Winch] = 0;
	motor[Forebar] = 0;
	motor[Roller] = 0;

	STARTING_ENCODER = nMotorEncoder[Forebar];
	nMotorEncoder[LeftMotor] = 0;
  nMotorEncoder[RightMotor] = 0;

	return;
}


task main()
{
	initializeRobot();
	waitForStart();
	int ForebarValue = STARTING_ENCODER;
	int ForebarMode = 0; //0 is PID, 1 is joystick
	int I = 0; //For PID
	while (true)
	{
  	//The drive train is controlled by Driver 1's left and right joysticks.
  	int leftJoystickPower = joystick.joy1_y1*100/128; //First controller: y value of the first joystick
  	int rightJoystickPower = joystick.joy1_y2*100/128; //First controller: y value of second joystick
  	leftJoystickPower = leftJoystickPower*2/3;
  	rightJoystickPower = rightJoystickPower*2/3;
  	if (abs(leftJoystickPower) < 20) //Deadzone
  	{leftJoystickPower = 0;}
  	if (abs(rightJoystickPower) < 20)
  	{rightJoystickPower = 0;}
		if (joy1Btn(6)) //Slow down
		{
			leftJoystickPower = leftJoystickPower/2;
			rightJoystickPower = rightJoystickPower/2;
		}
		if (joy1Btn(8)) //"Nitrous button" go at full power
		{
			leftJoystickPower = leftJoystickPower*3/2;
			rightJoystickPower = rightJoystickPower*3/2;
		}

  	motor[LeftMotor] = leftJoystickPower;
  	motor[RightMotor] = rightJoystickPower;

  	//Forebar is controlled by 5 and 7
  	//5 increases encoder value by 200, 7 decreases by 200.
  	//PID! Yay!
  	//Forebar initialized before the infinite loop started
		//Encoder goes backwards, so uh yeah...
		//If the forebar gets stuck, then the joystick can override the PID
  	int ForebarPower;
		if (ForebarMode == 0)
		{
			if (joy2Btn(5))
	  	{
	  		ForebarValue = STARTING_ENCODER-900;
	  		//while (joy2Btn(5))
	  		{}
	  	}
	  	if (joy2Btn(6))
	  	{
	  		ForebarValue = STARTING_ENCODER - 1100;
	  	}

	  	if (joy2Btn(7))
	  	{
	  		ForebarValue = STARTING_ENCODER;
	  	}

	  	if (joy2Btn(8))
	  	{
	  		ForebarValue = STARTING_ENCODER - 675;
	  	}
	  	/*
	  	if (ForebarValue > STARTING_ENCODER)
	  	{
	  		ForebarValue = STARTING_ENCODER;
	  	}
	  	*/

	  	int EncoderSwag = nMotorEncoder[Forebar];
			int error = ForebarValue - nMotorEncoder[Forebar];
			int P = error;
			if (I + error < 10000 && I + error > -10000)
			{
				I = I + error;
			}
			ForebarPower = -(P/8 + I/2000);

			/*
			if (ForebarPower > 70) //Don't let the motor power go above 30
			{
				ForebarPower = 70;
			}
			*/
			if (ForebarPower < -1) //NEVER let the motor power go below -1...
			{
				ForebarPower = -1;
			}
			if (ForebarPower < 0 & EncoderSwag < STARTING_ENCODER-250 & EncoderSwag >= STARTING_ENCODER-850)
			//if (ForebarPower < 0 & EncoderSwag < STARTING_ENCODER-200 & EncoderSwag >= STARTING_ENCODER-850) //If the forebar is in the air, gravity will let it fall.
			//if (ForebarPower < 0 & EncoderSwag >= STARTING_ENCODER-850)
			{
				ForebarPower = 0;
			}
			if (ForebarPower < 0 && EncoderSwag >= STARTING_ENCODER-75) //Turn off motors if near ground
			{
				ForebarPower = 0;
			}
			if (ForebarPower < 0 & EncoderSwag < STARTING_ENCODER-850) //If the forebar is in the air, gravity will let it fall.
			{
				ForebarPower = -1;
			}
			if (ForebarPower > 0 & ForebarPower < 14) //Deadzone so the motors are not always running and the #yoloswag sequence initiates
			{
				ForebarPower = 0;
			}
		}
		if (ForebarMode == 1) //Manual Forebar control
		{
			ForebarValue = nMotorEncoder[Forebar];
			STARTING_ENCODER = nMotorEncoder[Forebar];
			ForebarPower = joystick.joy2_y1*100/128; //swag yolo
			//ForebarPower = ForebarPower/2; //Otherwise the robot will do a backflip
			if (abs(ForebarPower) < 20)
			{
				ForebarPower = 0;
			}
			if (ForebarPower < 0) //When going down, limit the values
			{
				ForebarPower = ForebarPower/4;
			}
		}
		motor[Forebar] = ForebarPower;

		//Change the Forebar mode with button 10
		if (joy2Btn(10))
		{
			if (ForebarMode == 0)
			{
				ForebarMode = 1;
			}
			else
			{
				ForebarMode = 0;
			}
			while (joy2Btn(10))
			{}
		}

		//Servos are controlled by Driver 2's 2 and 4 button (A and Y)
 		if (joy2Btn(3) == 1)		//in
		{
	  	motor[Roller] = 100;
  	}
  	if (joy2Btn(2) == 1)			//out
		{
	  	motor[Roller] = -100;
  	}
  	if (joy2Btn(2) != 1 && joy2Btn(3) != 1 && joy2Btn(4) != 1 && joy2Btn(1) != 1)
  	{
	  	motor[Roller] = 0;
  	}
  	if (joy2Btn(4) == 1)	//in
  	{
  		motor[Roller] = 30;
  	}
  		if (joy2Btn(1) == 1)
  	{
  		motor[Roller] = -30;	//out
  	}

	}
}
